import io
import os

import matplotlib
import matplotlib as mpl
import numpy as np
from PIL import Image
from matplotlib import pyplot as plt
from rdkit import Geometry, Chem
from rdkit.Chem import Draw, AllChem
from rdkit.Chem import rdDepictor
from rdkit.Chem.Draw import rdMolDraw2D

DEFAULT_COLORMAP = 'coolwarm'  # "PiYG_r"#'coolwarm'
from collections import defaultdict
from typing import List, Union, Dict


def get_ecfp4_bit_info(smi: str, n_bits: int = 2048) -> Dict:
    """
    Returns dictionary of bit information generated by RDKit
    :param smi:
    :param n_bits:
    :return:
    """
    mol = Chem.MolFromSmiles(smi)
    dict_bitInfo = {}
    AllChem.GetMorganFingerprintAsBitVect(mol, 2, useChirality=False, bitInfo=dict_bitInfo, nBits=n_bits)
    return dict_bitInfo


def bit_to_atom_mapping(mol: Chem.Mol, dict_bit_info: dict) -> Dict[int, List[List[int]]]:
    """
    For the given molecule, create a dictionary of the following structure:
        key: bit
        value: list of lists
                each sublist contains atoms specifying the corresponding bit in the given compound
    :param mol: molecule
    :param dict_bit_info: bit information of this molecule
    :return:  dictionary containing the atom information for each bit
    """
    envs = {}
    for bit, matches in dict_bit_info.items():
        atoms = []
        for central_atom, radius in matches:
            if radius == 0:
                env_atoms = [central_atom]
            else:
                env = Chem.FindAtomEnvironmentOfRadiusN(mol, radius, central_atom, useHs=True)
                amap = {}
                _ = Chem.PathToSubmol(mol, env, atomMap=amap)
                env_atoms = list(amap)
            atoms.append(env_atoms)
        envs[bit] = atoms
    return envs


def assign_prediction_importance(bit_dict: Dict[int, List[List[int]]], weights: np.ndarray) -> Dict[int, float]:
    """
    Get the weighted individual SHAP values
    :param bit_dict:  bit to atom mapping for one molecule (outcome of bit_to_atom_mapping)
    :param weights: matrix of feature values to consider
    :return: dictionary:
                key: atom id
                value: contribution of this atom
    """
    atom_contribution = defaultdict(lambda: 0)
    for bit, atom_env_list in bit_dict.items():  # type: int, List[List[int]]
        n_matches = len(atom_env_list)
        for atom_set in atom_env_list:
            for atom in atom_set:
                atom_contribution[atom] += weights[bit] / (len(atom_set) * n_matches)
    return atom_contribution


def shap_to_atom_weight(mol: Chem.Mol, dict_bit_info: dict, shapley_values: np.ndarray) -> List[float]:
    """
    Get the Shapley value for each atom of the given molecule.
    For each bit in the molecule assume a uniform distribution of the Shapley value over all atoms belonging to this bit.
    For the atom-specific Shapley value: sum over all these weighted Shapley values
    :param mol: molecule to map Shapley values onto
    :param dict_bit_info: bit information of this molecule
    :param shapley_values: Shapley values to map
    :return: list of weights for each atom
    """
    bit_atom_env_dict = bit_to_atom_mapping(mol, dict_bit_info)
    atom_weight_dict = assign_prediction_importance(bit_atom_env_dict, shapley_values)
    atom_weight_list = [atom_weight_dict[a_idx] for a_idx in range(mol.GetNumAtoms())]
    return atom_weight_list


def get_atom_wise_weight_map(mol, weights, mol_size, cmap=DEFAULT_COLORMAP, return_png: bool = True) -> Union[
    Image.Image, Draw.MolDraw2D]:
    """
    Generate
    :param mol: molecule to display
    :param weights: weights to map onto the atoms
    :param mol_size: size of the molecule image
    :param cmap: colormap used for weight mapping
    :param return_png: if True: returns PNG image, if False, return Draw.MolDraw2D object
    :return:
    """
    draw2d = Draw.MolDraw2DCairo(*mol_size)
    draw2d.drawOptions().fixedScale = 0
    draw2d.drawOptions().useBWAtomPalette()

    mol = rdMolDraw2D.PrepareMolForDrawing(mol, addChiralHs=False)
    if not mol.GetNumConformers():
        Chem.rdDepictor.Compute2DCoords(mol)
    if mol.GetNumBonds() > 0:
        bond = mol.GetBondWithIdx(0)
        idx1 = bond.GetBeginAtomIdx()
        idx2 = bond.GetEndAtomIdx()
        sigma = 0.3 * (mol.GetConformer().GetAtomPosition(idx1) -
                       mol.GetConformer().GetAtomPosition(idx2)).Length()
    else:
        sigma = 0.3 * (mol.GetConformer().GetAtomPosition(0) -
                       mol.GetConformer().GetAtomPosition(1)).Length()
    sigma = round(sigma, 2)
    sigmas = [sigma] * mol.GetNumAtoms()
    locs = []
    for i in range(mol.GetNumAtoms()):
        p = mol.GetConformer().GetAtomPosition(i)
        locs.append(Geometry.Point2D(p.x, p.y))
    draw2d.ClearDrawing()
    ps = Draw.ContourParams()
    ps.fillGrid = True
    ps.gridResolution = 0.1
    ps.extraGridPadding = 2.0

    if isinstance(cmap, str):
        cmap = plt.get_cmap(cmap)
    # it's a matplotlib colormap:
    clrs = [tuple(cmap.get_under()), (1, 1, 1), tuple(cmap.get_over())]
    ps.setColourMap(clrs)

    contourLines = 10
    Draw.ContourAndDrawGaussians(draw2d, locs, weights, sigmas, nContours=contourLines, params=ps)
    draw2d.drawOptions().clearBackground = False
    draw2d.DrawMolecule(mol)

    if return_png:
        return convert_draw2d_to_png(draw2d)

    return draw2d


def get_atom_wise_weight_map_ref_mol(m, weights, mol_size, cmap=DEFAULT_COLORMAP, return_png: bool = True, ref_mol=None,
                                     highlightsub=None) -> Union[Image.Image, Draw.MolDraw2D]:
    """
    Generate
    :param mol: molecule to display
    :param weights: weights to map onto the atoms
    :param mol_size: size of the molecule image
    :param cmap: colormap used for weight mapping
    :param return_png: if True: returns PNG image, if False, return Draw.MolDraw2D object
    :return:
    """
    draw2d = Draw.MolDraw2DCairo(*mol_size)
    draw2d.drawOptions().fixedScale = 0
    draw2d.drawOptions().useBWAtomPalette()
    draw2d.drawOptions().continuousHighlight = False
    draw2d.drawOptions().circleAtoms = False
    # draw2d.drawOptions().scaleBondWidth = False
    #draw2d.drawOptions().highlightBondWidthMultiplier = 10
    draw2d.drawOptions().atomHighlightsAreCircles = False
    draw2d.drawOptions().setHighlightColour(
        (.0, .1, .6, 1))  # (.5,.1,.9,1) purple #(.0,.1,.9, 1) blue #(.0,.7,.4, 1) green

    if ref_mol:
        rdDepictor.SetPreferCoordGen(True)
        rdDepictor.Compute2DCoords(ref_mol)
        try:
            rdDepictor.GenerateDepictionMatching2DStructure(m, ref_mol, acceptFailure=False)
        except:
            rdDepictor.GenerateDepictionMatching2DStructure(m, ref_mol, acceptFailure=True)
        mol = rdMolDraw2D.PrepareMolForDrawing(m, addChiralHs=False)
    else:
        mol = rdMolDraw2D.PrepareMolForDrawing(m, addChiralHs=False)
    if not mol.GetNumConformers():
        Chem.rdDepictor.Compute2DCoords(mol)

    atm_n = [atom.GetIdx() for atom in list(mol.GetAtoms())]

    if mol.GetNumBonds() > 0:
        bond = mol.GetBondWithIdx(0)
        idx1 = bond.GetBeginAtomIdx()
        idx2 = bond.GetEndAtomIdx()
        sigma = 0.3 * (mol.GetConformer().GetAtomPosition(idx1) -
                       mol.GetConformer().GetAtomPosition(idx2)).Length()
    else:
        sigma = 0.3 * (mol.GetConformer().GetAtomPosition(0) -
                       mol.GetConformer().GetAtomPosition(1)).Length()
    sigma = round(sigma, 2)
    sigmas = [sigma] * mol.GetNumAtoms()
    locs = []
    for i in range(mol.GetNumAtoms()):
        p = mol.GetConformer().GetAtomPosition(i)
        locs.append(Geometry.Point2D(p.x, p.y))
    draw2d.ClearDrawing()
    ps = Draw.ContourParams()
    ps.fillGrid = True
    ps.gridResolution = 0.1
    ps.extraGridPadding = 2.0

    coolwarm = ((0.017, 0.50, 0.850, 1),
                (1, 1, 1, 1),
                (1, 0.25, 0.0, 1)
                )

    if isinstance(cmap, str):
        cmap = plt.get_cmap(cmap)
        # it's a matplotlib colormap:
        clrs = [tuple(cmap.get_under()), (1, 1, 1), tuple(cmap.get_over())]
    else:
        clrs = coolwarm

    ps.setColourMap(clrs)

    contourLines = 10
    Draw.ContourAndDrawGaussians(draw2d, locs, weights, sigmas, nContours=contourLines, params=ps)
    draw2d.drawOptions().clearBackground = False

    if highlightsub:
        match_atoms = m.GetSubstructMatch(Chem.MolFromSmarts(highlightsub))
        if match_atoms:
            highlight_atoms = list(set(match_atoms).symmetric_difference(set(atm_n)))
        else:
            highlight_atoms = None
        draw2d.DrawMolecule(mol, highlight_atoms)
    else:
        draw2d.DrawMolecule(mol)

    if return_png:
        return convert_draw2d_to_png(draw2d)

    return draw2d


def convert_draw2d_to_png(draw2d: Draw.MolDraw2D) -> Image.Image:
    """
    Convert a draw2d object to an PIL.Image
    :param draw2d:
    :return:
    """
    return Image.open(io.BytesIO(draw2d.GetDrawingText()))


def get_color_bar(figsize=(8, 3), cmap=DEFAULT_COLORMAP, ticklabels=['Low', '0', 'High'],
                  result_path=None, label='SHAP values', font_size = 20):


    font = {'size': font_size}
    matplotlib.rc('font', **font)
    fig = plt.figure(figsize=figsize)
    ax = fig.add_axes([0.05, 0.80, 0.9, 0.15])

    cmapl = [(0.017, 0.50, 0.850, 1),
             (1, 1, 1, 1),
             (1, 0.25, 0.0, 1)]

    if cmap is None:
        cmap = mpl.colors.LinearSegmentedColormap.from_list('my_colormap', cmapl,)

    cb1 = mpl.colorbar.ColorbarBase(ax, cmap=cmap,
                                    # ticks=[0, 0.5, 1],
                                    orientation='horizontal')
    cb1.set_label(label, fontsize=font_size)
    cb1.set_ticks([0, 0.5, 1])
    cb1.set_ticklabels(ticklabels, fontsize=font_size)
    plt.savefig(os.path.join(result_path, 'colorbar.png'), dpi=300, bbox_inches='tight')
